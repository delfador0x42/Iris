import Foundation
import os.log

/// Detects offensive security/exploitation tools on the system.
/// Frida, Cycript, Substrate, checkra1n, Cobalt Strike, and related tools.
/// Also detects anti-analysis and VM detection behaviors.
/// Covers hunt scripts: exploit_tools, security_tool_evasion.
public actor ExploitToolDetector {
    public static let shared = ExploitToolDetector()
    private let logger = Logger(subsystem: "com.wudan.iris", category: "ExploitTools")

    /// Known exploit/offensive tool binaries
    private let exploitBinaries: [(name: String, desc: String, sev: AnomalySeverity)] = [
        ("frida", "Frida dynamic instrumentation", .critical),
        ("frida-server", "Frida server (injection framework)", .critical),
        ("frida-ps", "Frida process list", .high),
        ("frida-trace", "Frida tracing", .high),
        ("cycript", "Cycript runtime injection", .critical),
        ("cynject", "Cydia injector", .critical),
        ("substrate", "Cydia Substrate hooking", .critical),
        ("checkra1n", "checkra1n jailbreak", .critical),
        ("palera1n", "palera1n jailbreak", .critical),
        ("gdb", "GNU Debugger", .medium),
        ("radare2", "Radare2 reverse engineering", .medium),
        ("r2", "Radare2 (short name)", .medium),
        ("objection", "Frida-based exploration", .high),
        ("needle", "iOS security testing", .high),
    ]

    public func scan(snapshot: ProcessSnapshot) async -> [ProcessAnomaly] {
        var anomalies: [ProcessAnomaly] = []
        anomalies.append(contentsOf: scanRunningExploitTools(snapshot: snapshot))
        anomalies.append(contentsOf: scanInstalledExploitTools())
        anomalies.append(contentsOf: scanAntiAnalysis(snapshot: snapshot))
        return anomalies
    }

    /// Check for exploit tools in running processes
    private func scanRunningExploitTools(snapshot: ProcessSnapshot) -> [ProcessAnomaly] {
        var result: [ProcessAnomaly] = []
        for pid in snapshot.pids {
            let name = snapshot.name(for: pid)
            let path = snapshot.path(for: pid)
            for tool in exploitBinaries where name.lowercased() == tool.name {
                result.append(.forProcess(
                    pid: pid, name: name, path: path,
                    technique: "Exploit Tool Running",
                    description: "\(tool.desc) is running (PID \(pid)). May indicate active exploitation.",
                    severity: tool.sev, mitreID: "T1203",
                    scannerId: "exploit_tool",
                    enumMethod: "ProcessSnapshot name matching",
                    evidence: [
                        "pid: \(pid)",
                        "tool: \(tool.name)",
                        "description: \(tool.desc)",
                        "path: \(path)",
                    ]
                ))
            }
        }
        return result
    }

    /// Check for exploit tools installed on disk
    private func scanInstalledExploitTools() -> [ProcessAnomaly] {
        var result: [ProcessAnomaly] = []
        let searchPaths = ["/usr/local/bin", "/opt/homebrew/bin",
                           "/usr/local/sbin", "/opt/local/bin"]
        let fm = FileManager.default

        for dir in searchPaths {
            guard let files = try? fm.contentsOfDirectory(atPath: dir) else { continue }
            for tool in exploitBinaries {
                if files.contains(tool.name) {
                    result.append(.filesystem(
                        name: tool.name, path: "\(dir)/\(tool.name)",
                        technique: "Exploit Tool Installed",
                        description: "\(tool.desc) installed at \(dir)/\(tool.name).",
                        severity: max(.medium, AnomalySeverity(rawValue: tool.sev.rawValue - 1) ?? .medium),
                        mitreID: "T1588.002",
                        scannerId: "exploit_tool",
                        enumMethod: "FileManager.contentsOfDirectory scan",
                        evidence: [
                            "tool: \(tool.name)",
                            "path: \(dir)/\(tool.name)",
                            "description: \(tool.desc)",
                        ]
                    ))
                }
            }
        }
        return result
    }

    /// Detect processes performing anti-analysis (VM detection, debugger detection)
    private func scanAntiAnalysis(snapshot: ProcessSnapshot) -> [ProcessAnomaly] {
        var result: [ProcessAnomaly] = []
        for pid in snapshot.pids {
            let name = snapshot.name(for: pid)
            let args = ProcessEnumeration.getProcessArguments(pid)
            let argStr = args.joined(separator: " ")

            // VM detection commands
            if (name == "ioreg" && argStr.contains("VirtualBox")) ||
               (name == "sysctl" && argStr.contains("hw.model")) ||
               (name == "system_profiler" && argStr.contains("SPHardwareDataType") && argStr.contains("grep")) {
                let path = snapshot.path(for: pid)
                result.append(.forProcess(
                    pid: pid, name: name, path: path,
                    technique: "VM/Sandbox Detection",
                    description: "\(name) performing virtual machine detection: \(argStr.prefix(80))",
                    severity: .high, mitreID: "T1497",
                    scannerId: "exploit_tool",
                    enumMethod: "sysctl(KERN_PROCARGS2) argument parsing",
                    evidence: [
                        "pid: \(pid)",
                        "binary: \(name)",
                        "args: \(argStr.prefix(120))",
                    ]
                ))
            }
        }
        return result
    }
}
